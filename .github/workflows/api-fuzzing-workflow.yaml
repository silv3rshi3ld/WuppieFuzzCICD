name: API Fuzzing Pipeline

on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main

permissions:
  contents: read

env:
  DOCKER_NETWORK_NAME: cicd_network
  VAMPI_RESTLER_PORT: 5012
  VAMPI_WUPPIEFUZZ_PORT: 5022
  VAMPI_EVOMASTER_PORT: 5032
  BASE_DIR: ${{ github.workspace }}

jobs:
  initialize_environment:
    runs-on: self-hosted
    outputs:
      runner-label: ${{ runner.name }}
      swarm-manager-ip: ${{ env.SWARM_MANAGER_IP }}
      swarm-worker-token: ${{ env.SWARM_WORKER_TOKEN }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Setup Base Directories
        run: |
          mkdir -p ${{ env.BASE_DIR }}/services/vampi
          mkdir -p ${{ env.BASE_DIR }}/workspace
          mkdir -p ${{ env.BASE_DIR }}/wuppiefuzz_workspace
          mkdir -p ${{ env.BASE_DIR }}/wuppiefuzz_bin
          mkdir -p $HOME/.cargo $HOME/.rustup
        shell: bash

      - name: Cleanup Previous Containers
        if: always()
        run: |
          echo "Cleaning up previous containers..."
          docker ps -q | xargs -r docker rm -f || true
          echo "Cleanup complete"
        shell: bash

      - name: Setup Docker Swarm
        run: |
          echo "Setting up Docker Swarm..."
          
          # Get the IP address (more robust method)
          IP=$(ip route get 1 | awk '{print $7;exit}' 2>/dev/null || hostname -I | awk '{print $1}')
          echo "Using IP: $IP"
          
          # Force leave any existing swarm
          docker swarm leave -f || true
          sleep 2
          
          echo "Initializing new swarm..."
          if docker swarm init --advertise-addr $IP; then
            echo "Successfully initialized swarm as manager"
            
            # Get and store join tokens
            MANAGER_TOKEN=$(docker swarm join-token manager -q)
            WORKER_TOKEN=$(docker swarm join-token worker -q)
            echo "SWARM_MANAGER_TOKEN=$MANAGER_TOKEN" >> $GITHUB_ENV
            echo "SWARM_WORKER_TOKEN=$WORKER_TOKEN" >> $GITHUB_ENV
            echo "SWARM_MANAGER_IP=$IP" >> $GITHUB_ENV
            
            # Create overlay network
            echo "Creating overlay network..."
            docker network rm ${{ env.DOCKER_NETWORK_NAME }} || true
            sleep 2
            docker network create \
              --driver overlay \
              --attachable \
              --subnet 10.0.0.0/16 \
              ${{ env.DOCKER_NETWORK_NAME }} || {
                echo "Failed to create network with subnet, trying without subnet..."
                docker network create --driver overlay --attachable ${{ env.DOCKER_NETWORK_NAME }}
              }
          else
            echo "Failed to initialize swarm, checking if we can join existing..."
            if [[ -n "${{ env.SWARM_WORKER_TOKEN }}" && -n "${{ env.SWARM_MANAGER_IP }}" ]]; then
              echo "Attempting to join existing swarm..."
              docker swarm join --token ${{ env.SWARM_WORKER_TOKEN }} ${{ env.SWARM_MANAGER_IP }}:2377
            else
              echo "No existing swarm credentials found. This might be the first run."
              exit 1
            fi
          fi
          
          # Verify setup
          echo "=== Swarm Status ==="
          docker info | grep -A5 "Swarm:"
          echo "=== Node List ==="
          docker node ls || echo "Not a manager node"
          echo "=== Network List ==="
          docker network ls
          echo "=== Network Details ==="
          docker network inspect ${{ env.DOCKER_NETWORK_NAME }} || echo "Network not accessible from this node"
        shell: bash

      - name: Verify Environment
        run: |
          echo "=== Environment Variables ==="
          env | grep SWARM || echo "No SWARM variables set"
          echo "=== Docker Info ==="
          docker info
          echo "=== Process List ==="
          ps aux | grep docker
        shell: bash

      - name: Verify Network
        run: |
          echo "Network details:"
          docker network inspect ${{ env.DOCKER_NETWORK_NAME }}
        shell: bash

  setup_target_application:
    runs-on: self-hosted
    needs: [initialize_environment]
    env:
      SWARM_MANAGER_IP: ${{ needs.initialize_environment.outputs.swarm-manager-ip }}
      SWARM_WORKER_TOKEN: ${{ needs.initialize_environment.outputs.swarm-worker-token }}
    strategy:
      matrix:
        fuzzer: [restler, wuppiefuzz, evomaster]
      fail-fast: false
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Verify Directory Structure
        run: |
          echo "Current directory: $(pwd)"
          echo "Contents of current directory:"
          ls -la
          echo "Contents of services directory:"
          ls -la services || echo "services directory not found"
        shell: bash

      - name: Start VAmPI Container
        run: |
          cd services/vampi
          
          # Cleanup any existing containers and networks
          echo "Cleaning up existing containers and networks..."
          docker compose down -v || true
          docker network rm ${{ env.DOCKER_NETWORK_NAME }} || true
          sleep 2
          
          # Create network with retry logic
          echo "Creating overlay network..."
          MAX_RETRIES=3
          RETRY_COUNT=0
          
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            if docker network create --driver overlay --attachable ${{ env.DOCKER_NETWORK_NAME }}; then
              echo "Network created successfully"
              break
            fi
            RETRY_COUNT=$((RETRY_COUNT + 1))
            if [ $RETRY_COUNT -eq $MAX_RETRIES ]; then
              echo "Failed to create network after $MAX_RETRIES attempts"
              exit 1
            fi
            echo "Failed to create network, attempt $RETRY_COUNT of $MAX_RETRIES"
            docker network rm ${{ env.DOCKER_NETWORK_NAME }} || true
            sleep 5
          done
          
          # Start containers
          echo "Starting VAmPI for ${{ matrix.fuzzer }} on port ${{ env.VAMPI_PORT }}"
          export PORT=${{ env.VAMPI_PORT }}
          export DOCKER_NETWORK_NAME=${{ env.DOCKER_NETWORK_NAME }}
          
          # Try to start containers with retry
          MAX_RETRIES=3
          RETRY_COUNT=0
          
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            if docker compose up -d; then
              # Wait for containers to be healthy
              for i in {1..30}; do
                if curl -s http://localhost:${{ env.VAMPI_PORT }}/api/v1/docs > /dev/null; then
                  echo "VAmPI is up and running"
                  docker compose ps
                  exit 0
                fi
                echo "Waiting for VAmPI to be ready... attempt $i/30"
                sleep 1
              done
            fi
            
            RETRY_COUNT=$((RETRY_COUNT + 1))
            echo "Failed to start/verify containers, attempt $RETRY_COUNT of $MAX_RETRIES"
            docker compose down -v
            sleep 5
          done
          
          echo "Failed to start containers after $MAX_RETRIES attempts"
          docker compose logs
          exit 1
        env:
          VAMPI_PORT: ${{ matrix.fuzzer == 'restler' && env.VAMPI_RESTLER_PORT || matrix.fuzzer == 'wuppiefuzz' && env.VAMPI_WUPPIEFUZZ_PORT || env.VAMPI_EVOMASTER_PORT }}
        shell: bash

  prepare_fuzzers:
    runs-on: self-hosted
    needs: [initialize_environment]
    env:
      SWARM_MANAGER_IP: ${{ needs.initialize_environment.outputs.swarm-manager-ip }}
      SWARM_WORKER_TOKEN: ${{ needs.initialize_environment.outputs.swarm-worker-token }}
    strategy:
      matrix:
        fuzzer: [restler, wuppiefuzz, evomaster]
      fail-fast: false
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Setup Fuzzer Environment
        run: |
          case "${{ matrix.fuzzer }}" in
            "restler")
              mkdir -p ${{ env.BASE_DIR }}/workspace/restler/{config,output}
              ;;
            "wuppiefuzz")
              mkdir -p ${{ env.BASE_DIR }}/wuppiefuzz_workspace
              mkdir -p ${{ env.BASE_DIR }}/wuppiefuzz_bin
              ;;
            "evomaster")
              mkdir -p ${{ env.BASE_DIR }}/workspace/evomaster/evomaster_results
              ;;
          esac
        shell: bash

      - name: Get WuppieFuzz Latest Commit
        if: matrix.fuzzer == 'wuppiefuzz'
        id: get-commit
        run: |
          LATEST_COMMIT=$(git ls-remote https://github.com/TNO-S3/WuppieFuzz.git HEAD | cut -f1)
          echo "commit=$LATEST_COMMIT" >> $GITHUB_OUTPUT
        shell: bash

      - name: Cache WuppieFuzz Binary
        if: matrix.fuzzer == 'wuppiefuzz'
        id: cache-wuppiefuzz
        uses: actions/cache@v4
        with:
          path: ${{ env.BASE_DIR }}/wuppiefuzz_bin
          key: wuppiefuzz-${{ steps.get-commit.outputs.commit }}
          restore-keys: |
            wuppiefuzz-

      - name: Setup Rust for WuppieFuzz
        if: matrix.fuzzer == 'wuppiefuzz' && steps.cache-wuppiefuzz.outputs.cache-hit != 'true'
        uses: dtolnay/rust-toolchain@stable
        with:
          components: rustfmt, clippy

      - name: Install Build Dependencies
        if: matrix.fuzzer == 'wuppiefuzz' && steps.cache-wuppiefuzz.outputs.cache-hit != 'true'
        run: |
          apt-get update
          apt-get install -y build-essential pkg-config libssl-dev
        shell: bash

      - name: Build WuppieFuzz
        if: matrix.fuzzer == 'wuppiefuzz' && steps.cache-wuppiefuzz.outputs.cache-hit != 'true'
        run: |
          git clone https://github.com/TNO-S3/WuppieFuzz.git ${{ env.BASE_DIR }}/wuppiefuzz_temp
          cd ${{ env.BASE_DIR }}/wuppiefuzz_temp
          cargo build --release
          cp target/release/wuppiefuzz ${{ env.BASE_DIR }}/wuppiefuzz_bin/
          cd ${{ env.BASE_DIR }}
          rm -rf wuppiefuzz_temp
        shell: bash

      - name: Upload WuppieFuzz Binary
        if: matrix.fuzzer == 'wuppiefuzz'
        uses: actions/upload-artifact@v4
        with:
          name: wuppiefuzz-binary
          path: ${{ env.BASE_DIR }}/wuppiefuzz_bin/wuppiefuzz
          if-no-files-found: error
          retention-days: 1

  prepare_openapi_specs:
    runs-on: self-hosted
    needs: [setup_target_application]
    if: always() && !contains(needs.*.result, 'failure')
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Generate OpenAPI Specs
        run: |
          for fuzzer in "restler" "wuppiefuzz" "evomaster"; do
            case $fuzzer in
              "restler")
                PORT=${{ env.VAMPI_RESTLER_PORT }}
                OUTPUT_DIR="${{ env.BASE_DIR }}/workspace/restler"
                ;;
              "wuppiefuzz")
                PORT=${{ env.VAMPI_WUPPIEFUZZ_PORT }}
                OUTPUT_DIR="${{ env.BASE_DIR }}/wuppiefuzz_workspace"
                ;;
              "evomaster")
                PORT=${{ env.VAMPI_EVOMASTER_PORT }}
                OUTPUT_DIR="${{ env.BASE_DIR }}/workspace/evomaster"
                ;;
            esac
            
            mkdir -p "$OUTPUT_DIR"
            cp ${{ env.BASE_DIR }}/services/vampi/openapi_specs/openapi3.yml "$OUTPUT_DIR/openapi3.yml"
            sed -i "s|http://localhost:5000|http://localhost:$PORT|g" "$OUTPUT_DIR/openapi3.yml"
          done
        shell: bash

  run_fuzzing:
    runs-on: self-hosted
    needs: [prepare_fuzzers, prepare_openapi_specs, setup_target_application]
    strategy:
      matrix:
        fuzzer: [restler, wuppiefuzz, evomaster]
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Run Fuzzer
        run: |
          case "${{ matrix.fuzzer }}" in
            "restler")
              cd services/restler || exit 1
              echo "Running RESTler fuzzer"
              docker compose -f docker-compose.restler.yml up --build
              ;;
              
            "wuppiefuzz")
              cd services/wuppiefuzz || exit 1
              echo "Running WuppieFuzz fuzzer"
              VAMPI_WUPPIEFUZZ_URL=http://vampi-vulnerable:5000 docker compose -f docker-compose.wuppie.yml up --build
              ;;
              
            "evomaster")
              cd services/evomaster || exit 1
              echo "Running EvoMaster fuzzer"
              docker compose -f docker-compose.evomaster.yml up --build
              ;;
          esac
        shell: bash

      - name: Upload Results
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.fuzzer }}-results
          path: |
            ${{ env.BASE_DIR }}/workspace/restler/output/**
            ${{ env.BASE_DIR }}/wuppiefuzz_workspace/reports/**
            ${{ env.BASE_DIR }}/workspace/evomaster/evomaster_results/**
          if-no-files-found: warn

      - name: Cleanup
        if: always()
        run: |
          cd ${{ env.BASE_DIR }}/services/vampi
          
          # Clean up all docker compose files and their containers
          for file in docker-compose.*.yaml; do
            if [ -f "$file" ]; then
              echo "Cleaning up $file"
              docker compose -f "$file" down --remove-orphans
            fi
          done
          
          # Additional cleanup of any stray containers
          docker ps -a | grep 'vampi-' | awk '{print $1}' | xargs -r docker rm -f
        shell: bash

  summarize_results:
    runs-on: self-hosted
    needs: run_fuzzing
    steps:
      - name: Download Fuzzer Results
        uses: actions/download-artifact@v4
        with:
          name: ${{ matrix.fuzzer }}-results
          path: all_results/${{ matrix.fuzzer }}-results
          if-no-files-found: warn

      - name: List Downloaded Artifacts
        run: |
          echo "Listing ${{ matrix.fuzzer }} Results:"
          ls -la all_results/${{ matrix.fuzzer }}-results || echo "${{ matrix.fuzzer }} results directory not found."
        shell: bash
        continue-on-error: true

      - name: Final Cleanup
        if: always()
        run: |
          echo "Pruning Docker containers..."
          docker container prune -f || echo "Failed to prune Docker containers."
          echo "Pruning Docker networks..."
          docker network prune -f || echo "Failed to prune Docker networks."
        shell: bash
