# API Fuzzing Pipeline with Docker Swarm

name: API Fuzzing Pipeline

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

permissions:
  contents: read

env:
  DOCKER_NETWORK_NAME: cicd_network
  VAMPI_RESTLER_PORT: 5012
  VAMPI_WUPPIEFUZZ_PORT: 5022
  VAMPI_EVOMASTER_PORT: 5032
  BASE_DIR: ${{ github.workspace }}
  FUZZERS: restler wuppiefuzz evomaster
  MAX_STARTUP_RETRIES: 3
  HEALTH_CHECK_TIMEOUT: 30
  NETWORK_TIMEOUT: 60

jobs:
  # 1. Initial cleanup
  cleanup:
    strategy:
      matrix:
        runner: [manager-runner, worker-runner]
      fail-fast: false
    runs-on: [self-hosted, "${{ matrix.runner }}"]
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4.0.0

      - name: Make Scripts Executable
        run: chmod +x ./scripts/*.sh

      - name: Cleanup Previous Setup
        run: ./scripts/cleanup-environment.sh "${{ env.DOCKER_NETWORK_NAME }}"
  # 2. Initialize Swarm infrastructure
  initialize_swarm:
    needs: cleanup
    runs-on: [self-hosted, manager-runner]
    outputs:
      swarm-manager-ip: ${{ steps.setup_swarm.outputs.swarm-manager-ip }}
      swarm-worker-token: ${{ steps.setup_swarm.outputs.swarm-worker-token }}
      network-id: ${{ steps.setup_network.outputs.network-id }}
      manager-hostname: ${{ steps.setup_swarm.outputs.manager-hostname }}
      swarm-initialized: ${{ steps.setup_swarm.outputs.swarm-initialized }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Count Active Runners
        id: count_runners
        run: |
          echo "TOTAL_RUNNERS=$(gh api /repos/${{ github.repository }}/actions/runners | jq '.total_count')" >> $GITHUB_ENV
        env:
          GH_TOKEN: ${{ github.token }}

      - name: Make manage-swarm.sh executable
        run: chmod +x ./scripts/manage-swarm.sh

      - name: Manage Swarm State
        id: setup_swarm
        env:
          MANAGER_IP: ${{ secrets.MANAGER_IP }}
        run: |
          # Run manage-swarm.sh and capture its exit status
          if ./scripts/manage-swarm.sh ${{ env.TOTAL_RUNNERS }}; then
            # Only set outputs if swarm initialization succeeded
            echo "swarm-manager-ip=$MANAGER_IP" >> $GITHUB_OUTPUT
            WORKER_TOKEN=$(sudo docker swarm join-token worker -q) || exit 1
            echo "swarm-worker-token=$WORKER_TOKEN" >> $GITHUB_OUTPUT
            echo "manager-hostname=$(hostname)" >> $GITHUB_OUTPUT
            echo "swarm-initialized=true" >> $GITHUB_OUTPUT
          else
            echo "::error::Swarm initialization failed"
            exit 1
          fi
      - name: Setup Docker Network
        id: setup_network
        run: ./scripts/setup-network.sh "${{ env.DOCKER_NETWORK_NAME }}"

      - name: Label Worker Nodes
        if: needs.initialize_swarm.outputs.swarm-initialized == 'true' && runner.name == needs.initialize_swarm.outputs.manager-hostname
        run: ./scripts/label-nodes.sh
  # 3. Configure Swarm Workers
  configure_workers:
    needs: initialize_swarm
    runs-on: [self-hosted, worker-runner]
    strategy:
      matrix:
        worker_id: [0] # Supports up to 3 workers, can be expanded as needed
      fail-fast: false
    steps:
      - name: Debug Runner Info
        run: |
          echo "Runner Name: ${{ runner.name }}"
          echo "Hostname: $(hostname)"
          echo "Manager Hostname: ${{ needs.initialize_swarm.outputs.manager-hostname }}"
      - name: Join Swarm (Worker Node)
        if: needs.initialize_swarm.outputs.swarm-initialized == 'true' && runner.name != needs.initialize_swarm.outputs.manager-hostname
        env:
          MANAGER_IP: ${{ secrets.MANAGER_IP }}
        run: |
          # Leave current swarm if already in one
          if sudo docker info 2>/dev/null | grep -q "Swarm: active"; then
            echo "Leaving current swarm..."
            sudo docker swarm leave --force
          fi
          # Configure Docker daemon and permissions
          sudo systemctl stop docker || true
          
          # Ensure /var/lib/docker exists with correct permissions
          sudo mkdir -p /var/lib/docker
          sudo chmod 711 /var/lib/docker
          
          # Reload and restart Docker
          sudo systemctl daemon-reload
          sudo systemctl start docker
          
          # Set correct ownership and permissions
          sudo chown -R root:root /var/lib/docker
          sudo chmod -R 711 /var/lib/docker
          
          # Wait for Docker to be ready
          timeout 30s bash -c 'until sudo docker info &>/dev/null; do sleep 1; done'
          
          # Verify manager IP
          echo "Attempting to join swarm at $MANAGER_IP:2377"
          if ! ping -c 1 $MANAGER_IP > /dev/null 2>&1; then
            echo "::error::Cannot ping manager at $MANAGER_IP"
            exit 1
          fi
          
          # Join swarm
          if ! timeout 30s sudo docker swarm join --token ${{ needs.initialize_swarm.outputs.swarm-worker-token }} $MANAGER_IP:2377; then
            echo "::error::Failed to join swarm"
            exit 1
          fi
  # 4. Verify Swarm setup
  verify_swarm:
    needs: [initialize_swarm, configure_workers]
    runs-on: [self-hosted, manager-runner]
    if: success()
    steps:
      - name: Verify Swarm and Network
        run: |
          # Verify swarm mode is active
          if ! sudo docker info | grep -q "Swarm: active"; then
            echo "::error::Not in swarm mode - swarm initialization may have failed"
            exit 1
          fi
          
          # Verify network exists and is overlay type
          if ! sudo docker network ls --filter driver=overlay | grep -q "${{ env.DOCKER_NETWORK_NAME }}"; then
            echo "::error::Required overlay network ${{ env.DOCKER_NETWORK_NAME }} not found"
            sudo docker network ls
            exit 1
          fi
          
          # List nodes and their roles
          echo "Swarm Nodes:"
          sudo docker node ls
          
          echo "Swarm configuration verified successfully"
  # 5. Prepare OpenAPI specs
  prepare_specs:
    needs: verify_swarm
    runs-on: [self-hosted, manager-runner]
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4.0.0

      - name: Copy OpenAPI Specs to Volumes
        run: |
          # Create temporary directory
          mkdir -p specs_temp
          cp services/vampi/openapi_specs/openapi3.yml specs_temp/
          
          # Copy specs to volumes
          sudo docker run --rm \
            -v $(pwd)/specs_temp:/source \
            -v openapi_spec:/dest \
            alpine cp /source/openapi3.yml /dest/
  # 6. Build and push images
  build_and_push_images:
    needs: verify_swarm
    runs-on: [self-hosted, manager-runner]
    outputs:
      vampi-restler-hash: ${{ steps.set_outputs.outputs.vampi-restler-hash }}
      vampi-wuppiefuzz-hash: ${{ steps.set_outputs.outputs.vampi-wuppiefuzz-hash }}
      vampi-evomaster-hash: ${{ steps.set_outputs.outputs.vampi-evomaster-hash }}
    strategy:
      matrix:
        service: [vampi-vulnerable, wuppiefuzz, restler, evomaster]
      fail-fast: false
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4.0.0

      - name: Setup Local Registry
        run: ./scripts/setup-registry.sh
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          driver: docker
          install: true
          platforms: linux/amd64
      - name: Calculate Image Hash
        id: hash
        run: |
          # Set registry address
          REGISTRY=localhost:5000
          
          # Determine service directory
          SERVICE_DIR=services/${{ matrix.service == 'vampi-vulnerable' && 'vampi' || matrix.service }}
          
          # Calculate hash of all files that affect the build
          if [ "${{ matrix.service }}" = "wuppiefuzz" ]; then
            # For WuppieFuzz, include the remote repo in hash calculation
            REMOTE_HASH=$(git ls-remote https://github.com/TNO-S3/WuppieFuzz.git HEAD | cut -f1)
            echo "WuppieFuzz remote hash: $REMOTE_HASH"
            HASH=$(echo "$REMOTE_HASH" | sha256sum | cut -d' ' -f1)
          else
            # For other services, hash the local files
            HASH=$(find $SERVICE_DIR -type f -exec sha256sum {} \; | sort | sha256sum | cut -d' ' -f1)
          fi
          
          echo "CONTENT_HASH=$HASH" >> $GITHUB_ENV
          echo "content_hash=$HASH" >> $GITHUB_OUTPUT

      - name: Check Existing Image
        id: check_image
        run: |
          REGISTRY=localhost:5000
          SERVICE=${{ matrix.service }}
          HASH=${{ steps.hash.outputs.content_hash }}
          
          if [ "$SERVICE" = "vampi-vulnerable" ]; then
            for FUZZER in restler wuppiefuzz evomaster; do
              # Check if image with this hash exists
              if curl -s "http://localhost:5000/v2/vampi-vulnerable-$FUZZER/tags/list" | grep -q "\"$HASH\""; then
                echo "Image vampi-vulnerable-$FUZZER:$HASH already exists"
                echo "VAMPI_${FUZZER}_TAG=$HASH" >> $GITHUB_ENV
              else
                echo "Need to build vampi-vulnerable-$FUZZER:$HASH"
                echo "BUILD_VAMPI_${FUZZER}=true" >> $GITHUB_ENV
              fi
            done
          else
            # Check if image with this hash exists
            if curl -s "http://localhost:5000/v2/$SERVICE/tags/list" | grep -q "\"$HASH\""; then
              echo "Image $SERVICE:$HASH already exists"
              echo "BUILD_NEEDED=false" >> $GITHUB_ENV
            else
              echo "Need to build $SERVICE:$HASH"
              echo "BUILD_NEEDED=true" >> $GITHUB_ENV
            fi
          fi

      - name: Build and Push Image
        run: |
          REGISTRY=localhost:5000
          SERVICE_DIR=services/${{ matrix.service == 'vampi-vulnerable' && 'vampi' || matrix.service }}
          DOCKERFILE=${{ matrix.service != 'vampi-vulnerable' && format('Dockerfile.{0}', matrix.service) || 'Dockerfile' }}
          HASH=${{ steps.hash.outputs.content_hash }}
          
          # For WuppieFuzz, ensure source code is available if needed
          if [ "${{ matrix.service }}" = "wuppiefuzz" ] && [ "$BUILD_NEEDED" = "true" ]; then
            echo "Preparing WuppieFuzz build context..."
            git clone https://github.com/TNO-S3/WuppieFuzz.git temp_wuppiefuzz
            cp -r temp_wuppiefuzz/* $SERVICE_DIR/
            rm -rf temp_wuppiefuzz
          fi
          
          cd $SERVICE_DIR
          
          # Special handling for VAmPI instances
          if [ "${{ matrix.service }}" = "vampi-vulnerable" ]; then
            for FUZZER in restler wuppiefuzz evomaster; do
              BUILD_VAR="BUILD_VAMPI_${FUZZER}"
              if [ "${!BUILD_VAR}" = "true" ]; then
                echo "Building VAmPI for $FUZZER"
                sudo docker build \
                  --file $DOCKERFILE \
                  --build-arg vulnerable=1 \
                  --tag $REGISTRY/vampi-vulnerable-$FUZZER:$HASH \
                  --network host \
                  . && \
                sudo docker push $REGISTRY/vampi-vulnerable-$FUZZER:$HASH
                
                echo "VAMPI_${FUZZER}_TAG=$HASH" >> $GITHUB_ENV
              fi
            done
          elif [ "$BUILD_NEEDED" = "true" ]; then
            # Build other services only if needed
            sudo docker build \
              --file $DOCKERFILE \
              --tag $REGISTRY/${{ matrix.service }}:$HASH \
              --tag $REGISTRY/${{ matrix.service }}:latest \
              --network host \
              . && \
            sudo docker push $REGISTRY/${{ matrix.service }}:$HASH && \
            sudo docker push $REGISTRY/${{ matrix.service }}:latest
          fi

      - name: Set Job Outputs
        id: set_outputs
        if: matrix.service == 'vampi-vulnerable'
        run: |
          echo "vampi-restler-hash=${{ env.VAMPI_restler_TAG }}" >> $GITHUB_OUTPUT
          echo "vampi-wuppiefuzz-hash=${{ env.VAMPI_wuppiefuzz_TAG }}" >> $GITHUB_OUTPUT
          echo "vampi-evomaster-hash=${{ env.VAMPI_evomaster_TAG }}" >> $GITHUB_OUTPUT

  # 7. Deploy stack
  deploy_stack:
    needs: [prepare_specs, build_and_push_images]
    runs-on: [self-hosted, manager-runner]
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4.0.0

      - name: Create Stack File with Hash Tags
        run: |
          cat > docker-swarm.yml << 'EOL'
          version: '3.8'
          services:
            vampi-restler:
              image: localhost:5000/vampi-vulnerable-restler:${{ needs.build_and_push_images.outputs.vampi-restler-hash }}
              environment:
                - vulnerable=1
              ports:
                - "5012:5000"
              networks:
                - cicd_network
              deploy:
                placement:
                  constraints:
                    - node.labels.fuzzer == restler

            vampi-wuppiefuzz:
              image: localhost:5000/vampi-vulnerable-wuppiefuzz:${{ needs.build_and_push_images.outputs.vampi-wuppiefuzz-hash }}
              environment:
                - vulnerable=1
              ports:
                - "5022:5000"
              networks:
                - cicd_network
              deploy:
                placement:
                  constraints:
                    - node.labels.fuzzer == wuppiefuzz

            vampi-evomaster:
              image: localhost:5000/vampi-vulnerable-evomaster:${{ needs.build_and_push_images.outputs.vampi-evomaster-hash }}
              environment:
                - vulnerable=1
              ports:
                - "5032:5000"
              networks:
                - cicd_network
              deploy:
                placement:
                  constraints:
                    - node.labels.fuzzer == evomaster

          networks:
            cicd_network:
              external: true
              name: cicd_network
          EOL

      - name: Deploy Stack
        run: |
          # Make deploy script executable
          sudo chmod +x ./scripts/deploy-stack.sh
          
          # Run deploy script
          sudo ./scripts/deploy-stack.sh
  # 8. Run fuzzing
  run_fuzzing:
    needs: deploy_stack
    runs-on: [self-hosted, worker-runner]
    strategy:
      matrix:
        fuzzer: [restler, wuppiefuzz, evomaster]
      fail-fast: false
    steps:
      - name: Run Fuzzing Tests
        run: |
          # Determine VAmPI port based on fuzzer
          case "${{ matrix.fuzzer }}" in
            "restler")
              VAMPI_PORT=${{ env.VAMPI_RESTLER_PORT }}
              ;;
            "wuppiefuzz")
              VAMPI_PORT=${{ env.VAMPI_WUPPIEFUZZ_PORT }}
              ;;
            "evomaster")
              VAMPI_PORT=${{ env.VAMPI_EVOMASTER_PORT }}
              ;;
          esac
          
          ./scripts/monitor-fuzzing.sh "${{ matrix.fuzzer }}" "$VAMPI_PORT" 3600
      - name: Collect Results
        run: |
          mkdir -p fuzzing_results/${{ matrix.fuzzer }}
          
          # Copy results from volumes
          sudo docker run --rm \
            -v ${{ matrix.fuzzer }}_output:/results \
            -v $(pwd)/fuzzing_results/${{ matrix.fuzzer }}:/output \
            alpine cp -r /results/* /output/
      - name: Upload Results
        uses: actions/upload-artifact@v4
        with:
          name: fuzzing-results-${{ matrix.fuzzer }}
          path: fuzzing_results/${{ matrix.fuzzer }}
          retention-days: 7

  # 9. Summarize results
  summarize_results:
    needs: run_fuzzing
    runs-on: [self-hosted, manager-runner]
    if: always()
    steps:
      - name: Download Results
        uses: actions/download-artifact@v4
        with:
          pattern: fuzzing-results-*
          path: all_results
          merge-multiple: true

      - name: List Results
        run: |
          echo "Listing Results:"
          ls -la all_results || echo "No results found."
      - name: Final Cleanup
        run: |
          echo "No additional cleanup needed - already handled in initial cleanup job"
