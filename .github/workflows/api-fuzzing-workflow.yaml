name: API Fuzzing Pipeline

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

permissions:
  contents: read

env:
  DOCKER_NETWORK_NAME: cicd_network
  VAMPI_RESTLER_PORT: 5012
  VAMPI_WUPPIEFUZZ_PORT: 5022
  VAMPI_EVOMASTER_PORT: 5032
  BASE_DIR: ${{ github.workspace }}
  FUZZERS: restler wuppiefuzz evomaster
  MAX_STARTUP_RETRIES: 3
  HEALTH_CHECK_TIMEOUT: 30
  NETWORK_TIMEOUT: 60

jobs:
  cleanup:
    runs-on: self-hosted
    steps:
      - name: Cleanup Previous Setup
        run: |
          echo "Cleaning up previous setup..."
          # Kill any processes using known ports
          for port in ${{ env.VAMPI_RESTLER_PORT }} ${{ env.VAMPI_WUPPIEFUZZ_PORT }} ${{ env.VAMPI_EVOMASTER_PORT }}; do
            pid=$(lsof -ti :$port) || true
            if [ -n "$pid" ]; then
              echo "Killing process using port $port"
              kill -9 $pid || echo "Failed to kill process on port $port"
            fi
          done

          # Cleanup Docker containers
          if docker ps -q | grep -q .; then
            docker ps -q | xargs docker stop || echo "Failed to stop some running containers"
          fi
          if docker ps -aq | grep -q .; then
            docker ps -aq | xargs docker rm || echo "Failed to remove some containers"
          fi

          # Cleanup Docker network
          if docker network ls | grep -q "${{ env.DOCKER_NETWORK_NAME }}"; then
            if ! docker network rm "${{ env.DOCKER_NETWORK_NAME }}"; then
              echo "Failed to remove network ${{ env.DOCKER_NETWORK_NAME }}, it might be in use"
            fi
          fi

          echo "Cleanup completed."
          sleep 5

  initialize_swarm:
    needs: cleanup
    runs-on: self-hosted
    outputs:
      swarm-manager-ip: ${{ steps.setup_swarm.outputs.swarm-manager-ip }}
      swarm-worker-token: ${{ steps.setup_swarm.outputs.swarm-worker-token }}
      network-id: ${{ steps.setup_network.outputs.network-id }}
      manager-hostname: ${{ steps.setup_swarm.outputs.manager-hostname }}
      swarm-initialized: ${{ steps.setup_swarm.outputs.swarm-initialized }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Count Active Runners
        id: count_runners
        run: |
          echo "TOTAL_RUNNERS=$(gh api /repos/${{ github.repository }}/actions/runners | jq '.total_count')" >> $GITHUB_ENV
        env:
          GH_TOKEN: ${{ github.token }}

      - name: Make manage-swarm.sh executable
        run: chmod +x ./scripts/manage-swarm.sh

      - name: Manage Swarm State
        if: ${{ runner.name == 'TNO' }}
        env:
          MANAGER_IP: ${{ secrets.MANAGER_IP }}
        run: |
          ./scripts/manage-swarm.sh ${{ env.TOTAL_RUNNERS }}
          
          # Set outputs for other jobs
          echo "swarm-manager-ip=${{ secrets.MANAGER_IP }}" >> $GITHUB_OUTPUT
          WORKER_TOKEN=$(docker swarm join-token worker -q)
          echo "swarm-worker-token=$WORKER_TOKEN" >> $GITHUB_OUTPUT
          echo "manager-hostname=$(hostname)" >> $GITHUB_OUTPUT
          echo "swarm-initialized=true" >> $GITHUB_OUTPUT

      - name: Setup Docker Network
        id: setup_network
        if: ${{ runner.name == 'TNO' }}
        run: |
          # Check if network exists first
          if ! docker network ls | grep -q "${{ env.DOCKER_NETWORK_NAME }}"; then
            echo "Creating overlay network ${{ env.DOCKER_NETWORK_NAME }}"
            NETWORK_ID=$(docker network create --driver overlay --attachable ${{ env.DOCKER_NETWORK_NAME }})
            echo "network-id=$NETWORK_ID" >> $GITHUB_OUTPUT
          else
            echo "Network ${{ env.DOCKER_NETWORK_NAME }} already exists"
            NETWORK_ID=$(docker network ls --filter name=${{ env.DOCKER_NETWORK_NAME }} --format "{{.ID}}")
            echo "network-id=$NETWORK_ID" >> $GITHUB_OUTPUT
          fi
          
          # Verify network was created/exists and is overlay type
          if ! docker network inspect ${{ env.DOCKER_NETWORK_NAME }} --format "{{.Driver}}" | grep -q "overlay"; then
            echo "::error::Network ${{ env.DOCKER_NETWORK_NAME }} is not an overlay network"
            exit 1
          fi

  join_swarm:
    needs: initialize_swarm
    runs-on: self-hosted
    strategy:
      matrix:
        fuzzer: [restler, wuppiefuzz, evomaster]
      fail-fast: false
    steps:
      - name: Debug Runner Information
        run: |
          echo "Runner Name: ${{ runner.name }}"
          echo "Hostname: $(hostname)"
          echo "Runner Labels: ${{ runner.labels }}"

      - name: Verify Runner for Swarm Joining
        if: ${{ runner.name == 'TNO2' }}
        run: echo "Runner is TNO2 - proceeding with swarm joining."

      - name: Skip Swarm Joining on Non-Worker Runners
        if: ${{ runner.name != 'TNO2' }}
        run: echo "Runner is not TNO2 - skipping swarm joining."

      - name: Cleanup Worker Before Joining
        if: ${{ runner.name == 'TNO2' && needs.initialize_swarm.outputs.swarm-initialized == 'true' }}
        run: |
          # Kill processes using known ports
          for port in ${{ env.VAMPI_RESTLER_PORT }} ${{ env.VAMPI_WUPPIEFUZZ_PORT }} ${{ env.VAMPI_EVOMASTER_PORT }}; do
            pid=$(lsof -ti :$port) || true
            if [ -n "$pid" ]; then
              echo "Killing process using port $port"
              kill -9 $pid || echo "Failed to kill process on port $port"
            fi
          done

          # Cleanup Docker resources
          if docker ps -q | grep -q .; then
            docker ps -q | xargs docker stop || echo "Failed to stop some running containers"
          fi
          if docker ps -aq | grep -q .; then
            docker ps -aq | xargs docker rm || echo "Failed to remove some containers"
          fi

          # Leave any existing swarm
          if docker info --format '{{.Swarm.LocalNodeState}}' | grep -q 'active'; then
            docker swarm leave --force || echo "::warning::Failed to leave previous swarm."
          fi

          sleep 5

      - name: Join Swarm
        if: ${{ runner.name == 'TNO2' && needs.initialize_swarm.outputs.swarm-initialized == 'true' }}
        shell: bash
        run: |
          HOSTNAME=$(hostname)
          echo "Current Hostname: $HOSTNAME"
          echo "Manager Hostname: ${{ needs.initialize_swarm.outputs.manager-hostname }}"
          echo "Manager IP: ${{ secrets.MANAGER_IP }}"

          if [ "$HOSTNAME" == "${{ needs.initialize_swarm.outputs.manager-hostname }}" ]; then
            echo "This is the manager node, skipping join."
          else
            echo "Joining swarm as worker..."
            
            # Ensure Docker daemon is running with proper network settings
            sudo systemctl stop docker || true
            sudo sed -i 's/^ExecStart=.*/ExecStart=\/usr\/bin\/dockerd -H fd:\/\/ --containerd=\/run\/containerd\/containerd.sock --iptables=true --ip-masq=true --ip-forward=true/' /lib/systemd/system/docker.service
            sudo systemctl daemon-reload
            sudo systemctl start docker
            
            # Wait for Docker to be ready
            echo "Waiting for Docker to be ready..."
            timeout 30s bash -c 'until docker info &>/dev/null; do sleep 1; done'
            
            # Verify connectivity to manager
            echo "Verifying connectivity to manager..."
            if ! timeout 5s bash -c "</dev/tcp/${{ secrets.MANAGER_IP }}/2377"; then
              echo "::error::Cannot connect to manager port 2377"
              exit 1
            fi
            
            # Try joining with increased timeout
            if ! timeout 30s docker swarm join --token ${{ needs.initialize_swarm.outputs.swarm-worker-token }} ${{ secrets.MANAGER_IP }}:2377; then
              echo "::error::Failed to join swarm"
              docker swarm leave --force || true
              exit 1
            fi
            echo "Successfully joined swarm"

            # Verify node joined successfully with increased timeout
            echo "Verifying node joined successfully..."
            for i in $(seq 1 60); do
              if docker node ls 2>/dev/null | grep -q "$(hostname)"; then
                echo "Node successfully joined and visible in swarm"
                break
              fi
              if [ $i -eq 60 ]; then
                echo "::error::Node failed to appear in swarm after joining"
                exit 1
              fi
              echo "Waiting for node to appear in swarm... attempt $i/60"
              sleep 2
            done

            # Add node labels
            echo "Adding node labels..."
            if docker node ls --filter role=worker | grep -q "$(hostname)"; then
              docker node update --label-add type=fuzzer $(hostname)
            fi

  setup_target_application:
    needs: [initialize_swarm, join_swarm]
    runs-on: self-hosted
    strategy:
      matrix:
        fuzzer: [restler, wuppiefuzz, evomaster]
      fail-fast: false
    steps:
      - name: Verify Swarm and Network
        run: |
          # Verify swarm mode is active
          if ! docker info | grep -q "Swarm: active"; then
            echo "::error::Not in swarm mode - swarm initialization may have failed"
            exit 1
          fi

          # Verify network exists and is overlay type
          if ! docker network ls --filter driver=overlay | grep -q "${{ env.DOCKER_NETWORK_NAME }}"; then
            echo "::error::Required overlay network ${{ env.DOCKER_NETWORK_NAME }} not found"
            docker network ls
            exit 1
          fi

          echo "Swarm mode and network verified successfully"

      - name: Checkout Repository
        uses: actions/checkout@v4.0.0

      - name: Set VAMPI_PORT
        run: |
          case "${{ matrix.fuzzer }}" in
            "restler")
              echo "VAMPI_PORT=${{ env.VAMPI_RESTLER_PORT }}" >> $GITHUB_ENV
              ;;
            "wuppiefuzz")
              echo "VAMPI_PORT=${{ env.VAMPI_WUPPIEFUZZ_PORT }}" >> $GITHUB_ENV
              ;;
            "evomaster")
              echo "VAMPI_PORT=${{ env.VAMPI_EVOMASTER_PORT }}" >> $GITHUB_ENV
              ;;
          esac

      - name: Start VAmPI
        run: |
          cd services/vampi

          pid=$(lsof -ti :$VAMPI_PORT) || true
          if [ -n "$pid" ]; then
            echo "Killing process using port $VAMPI_PORT"
            kill -9 $pid || echo "Failed to kill process on port $VAMPI_PORT"
          fi

          # Remove any existing stack
          docker stack rm vampi-${{ matrix.fuzzer }} || true
          sleep 5

          export PORT=$VAMPI_PORT
          export DOCKER_NETWORK_NAME=${{ env.DOCKER_NETWORK_NAME }}

          # Deploy stack using docker stack deploy
          RETRY_COUNT=0
          while [ $RETRY_COUNT -lt ${{ env.MAX_STARTUP_RETRIES }} ]; do
            echo "Starting VAmPI Stack (Attempt $((RETRY_COUNT + 1))/${{ env.MAX_STARTUP_RETRIES }})"
            
            # Deploy the stack
            if docker stack deploy -c docker-compose.yaml vampi-${{ matrix.fuzzer }}; then
              # Wait for services to be running
              for i in $(seq 1 30); do
                RUNNING_COUNT=$(docker stack services vampi-${{ matrix.fuzzer }} --format "{{.Replicas}}" | grep -c "1/1" || echo "0")
                EXPECTED_COUNT=2  # We expect 2 services: vampi-secure and vampi-vulnerable
                if [ "$RUNNING_COUNT" -eq "$EXPECTED_COUNT" ]; then
                  echo "All services are running in swarm"
                  docker stack services vampi-${{ matrix.fuzzer }}
                  break
                fi
                echo "Waiting for services to start... ($i/30) - Running: $RUNNING_COUNT/2"
                sleep 2
              done

              # Check application health
              for i in $(seq 1 ${{ env.HEALTH_CHECK_TIMEOUT }}); do
                if curl -s http://localhost:$VAMPI_PORT/api/v1/docs > /dev/null; then
                  echo "VAmPI is healthy and responding"
                  break 2
                fi
                echo "Waiting for VAmPI to be ready... ($i/${{ env.HEALTH_CHECK_TIMEOUT }})"
                sleep 1
              done
            fi

            echo "::warning::Attempt $((RETRY_COUNT + 1)) failed, cleaning up..."
            docker stack rm vampi-${{ matrix.fuzzer }}
            sleep 10
            RETRY_COUNT=$((RETRY_COUNT + 1))
          done

          if [ $RETRY_COUNT -eq ${{ env.MAX_STARTUP_RETRIES }} ]; then
            echo "::error::Failed to start VAmPI after ${{ env.MAX_STARTUP_RETRIES }} attempts"
            docker stack services vampi-${{ matrix.fuzzer }} || true
            docker service logs vampi-${{ matrix.fuzzer }}_vampi-secure || true
            docker service logs vampi-${{ matrix.fuzzer }}_vampi-vulnerable || true
            docker network inspect "${{ env.DOCKER_NETWORK_NAME }}" || true
            exit 1
          fi

  prepare_fuzzers:
    needs: [initialize_swarm]
    runs-on: self-hosted
    strategy:
      matrix:
        fuzzer: [restler, wuppiefuzz, evomaster]
      fail-fast: false
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4.0.0

      - name: Setup RESTler
        if: matrix.fuzzer == 'restler'
        run: |
          echo "Setting up RESTler..."
          # RESTler setup steps here

      - name: Setup WuppieFuzz
        if: matrix.fuzzer == 'wuppiefuzz'
        run: |
          echo "Setting up WuppieFuzz..."
          # WuppieFuzz setup steps here

      - name: Setup EvoMaster
        if: matrix.fuzzer == 'evomaster'
        run: |
          echo "Setting up EvoMaster..."
          cd "${{ github.workspace }}/services/evomaster"
          ls -la  # Debug: list files
          docker compose -f docker-compose.evomaster.yml build
          mkdir -p evomaster_results

      - name: Upload Fuzzer Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: fuzzer-${{ matrix.fuzzer }}-artifacts
          path: tools
          retention-days: 1

  prepare_openapi_specs:
    needs: [setup_target_application]
    runs-on: self-hosted
    if: always()
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4.0.0

      - name: Generate OpenAPI Specs
        run: |
          for fuzzer in restler wuppiefuzz evomaster; do
            case $fuzzer in
              restler)
                PORT=${{ env.VAMPI_RESTLER_PORT }}
                OUTPUT_DIR="${{ env.BASE_DIR }}/workspace/restler"
                ;;
              wuppiefuzz)
                PORT=${{ env.VAMPI_WUPPIEFUZZ_PORT }}
                OUTPUT_DIR="${{ env.BASE_DIR }}/wuppiefuzz_workspace"
                ;;
              evomaster)
                PORT=${{ env.VAMPI_EVOMASTER_PORT }}
                OUTPUT_DIR="${{ env.BASE_DIR }}/evomaster_workspace"
                ;;
            esac
            
            mkdir -p "$OUTPUT_DIR"
            cp ${{ env.BASE_DIR }}/services/vampi/openapi_specs/openapi3.yml "$OUTPUT_DIR/openapi3.yml"
            sed -i "s|http://localhost:5000|http://localhost:$PORT|g" "$OUTPUT_DIR/openapi3.yml"
          done

      - name: Upload OpenAPI Specs
        uses: actions/upload-artifact@v4
        with:
          name: openapi-specs
          path: |
            ${{ env.BASE_DIR }}/workspace/restler/openapi3.yml
            ${{ env.BASE_DIR }}/wuppiefuzz_workspace/openapi3.yml
            ${{ env.BASE_DIR }}/evomaster_workspace/openapi3.yml
          retention-days: 1

  run_fuzzing:
    needs: [prepare_fuzzers, prepare_openapi_specs, setup_target_application]
    runs-on: self-hosted
    strategy:
      matrix:
        fuzzer: [restler, wuppiefuzz, evomaster]
      fail-fast: false
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4.0.0

      - name: Download Fuzzer Artifacts
        uses: actions/download-artifact@v4
        with:
          name: fuzzer-${{ matrix.fuzzer }}-artifacts
          path: tools

      - name: Download OpenAPI Specs
        uses: actions/download-artifact@v4
        with:
          name: openapi-specs
          path: openapi_specs

      - name: Set VAMPI_PORT
        run: |
          case "${{ matrix.fuzzer }}" in
            "restler")
              echo "VAMPI_PORT=${{ env.VAMPI_RESTLER_PORT }}" >> $GITHUB_ENV
              ;;
            "wuppiefuzz")
              echo "VAMPI_PORT=${{ env.VAMPI_WUPPIEFUZZ_PORT }}" >> $GITHUB_ENV
              ;;
            "evomaster")
              echo "VAMPI_PORT=${{ env.VAMPI_EVOMASTER_PORT }}" >> $GITHUB_ENV
              ;;
          esac

      - name: Run RESTler
        if: matrix.fuzzer == 'restler'
        run: |
          echo "Running RESTler..."
          
          mkdir -p ${{ github.workspace }}/workspace
          mkdir -p ${{ github.workspace }}/workspace/output
          
          cp -r ${{ github.workspace }}/restler/restler_config ${{ github.workspace }}/workspace/
          cp ${{ github.workspace }}/restler/docker-compose-restler.yml ${{ github.workspace }}/workspace/
          cp ${{ github.workspace }}/restler/Dockerfile.restler ${{ github.workspace }}/workspace/
          cp ${{ github.workspace }}/services/vampi/openapi_specs/openapi3.yml ${{ github.workspace }}/workspace/openapi3.yml
          echo "Files in workspace:"
          ls -la ${{ github.workspace }}/workspace/
          
          cd ${{ github.workspace }}/workspace
          docker-compose -f docker-compose-restler.yml up --build

      - name: Run WuppieFuzz
        if: matrix.fuzzer == 'wuppiefuzz'
        run: |
          echo "Running WuppieFuzz..."
          
          mkdir -p ${{ github.workspace }}/wuppiefuzz_workspace

          uses: actions/download-artifact@v4
          with:
            name: wuppiefuzz-binary
            path: ${{ github.workspace }}/wuppiefuzz_workspace/wuppiefuzz

          uses: actions/download-artifact@v4
          with:
            name: vampi-api
            path: ${{ github.workspace }}/wuppiefuzz_workspace/VAmPI-master

          run: chmod +x ${{ github.workspace }}/wuppiefuzz_workspace/wuppiefuzz/wuppiefuzz

          cd ${{ github.workspace }}/wuppiefuzz_workspace
          echo "Current directory structure:"
          ls -R
          mkdir reports
          ./wuppiefuzz/wuppiefuzz output-corpus \
            --openapi-spec=VAmPI-master/openapi_specs/openapi3.yml \
            corpus_directory
          ./wuppiefuzz/wuppiefuzz fuzz \
            --report=true \
            --log-level=info \
            --initial-corpus=corpus_directory \
            --timeout=60 \
            VAmPI-master/openapi_specs/openapi3.yml

      - name: Run EvoMaster
        if: matrix.fuzzer == 'evomaster'
        run: |
          echo "Running EvoMaster..."
          cd "${{ github.workspace }}/services/evomaster"
          docker compose -f docker-compose.evomaster.yml run --rm evomaster \
            -e SPEC_PATH="/specs/openapi3.yml" \
            -e OUTPUT_DIR="/evomaster/results" \
            -e TARGET_URL="http://vampi-vulnerable-evomaster:${{ env.VAMPI_PORT }}" \
            -e TIME_BUDGET="600"

      - name: Upload Fuzzing Results
        uses: actions/upload-artifact@v4
        with:
          name: fuzzing-results-${{ matrix.fuzzer }}
          path: |
            tools/**/results
            tools/**/output
          retention-days: 1

  summarize_results:
    needs: run_fuzzing
    runs-on: self-hosted
    if: always()
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4.0.0

      - name: Download RESTler Results
        uses: actions/download-artifact@v4
        with:
          name: fuzzing-results-restler
          path: all_results/restler-results

      - name: Download WuppieFuzz Results
        uses: actions/download-artifact@v4
        with:
          name: fuzzing-results-wuppiefuzz
          path: all_results/wuppiefuzz-results

      - name: Download EvoMaster Results
        uses: actions/download-artifact@v4
        with:
          name: fuzzing-results-evomaster
          path: all_results/evomaster-results

      - name: List Downloaded Artifacts
        run: |
          echo "Listing RESTler Results:"
          ls -la all_results/restler-results || echo "No RESTler results found."
          echo "Listing WuppieFuzz Results:"
          ls -la all_results/wuppiefuzz-results || echo "No WuppieFuzz results found."
          echo "Listing EvoMaster Results:"
          ls -la all_results/evomaster-results || echo "No EvoMaster results found."

      - name: Final Cleanup
        run: |
          echo "Pruning Docker containers..."
          docker container prune -f || echo "Failed to prune Docker containers."
          echo "Pruning Docker networks..."
          docker network prune -f || echo "Failed to prune Docker networks."
