name: API Fuzzing Pipeline

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

permissions:
  contents: read

env:
  DOCKER_NETWORK_NAME: cicd_network
  VAMPI_RESTLER_PORT: 5012
  VAMPI_WUPPIEFUZZ_PORT: 5022
  VAMPI_EVOMASTER_PORT: 5032
  BASE_DIR: ${{ github.workspace }}
  FUZZERS: restler wuppiefuzz evomaster
  MAX_STARTUP_RETRIES: 3
  HEALTH_CHECK_TIMEOUT: 30
  NETWORK_TIMEOUT: 60

jobs:
  cleanup:
    runs-on: self-hosted
    steps:
      - name: Cleanup Previous Setup
        run: |
          echo "Cleaning up previous setup..."
          # Kill any processes using known ports
          for port in ${{ env.VAMPI_RESTLER_PORT }} ${{ env.VAMPI_WUPPIEFUZZ_PORT }} ${{ env.VAMPI_EVOMASTER_PORT }}; do
            pid=$(lsof -ti :$port) || true
            if [ -n "$pid" ]; then
              echo "Killing process using port $port"
              kill -9 $pid || echo "Failed to kill process on port $port"
            fi
          done

          # Cleanup Docker containers
          if docker ps -q | grep -q .; then
            docker ps -q | xargs docker stop || echo "Failed to stop some running containers"
          fi
          if docker ps -aq | grep -q .; then
            docker ps -aq | xargs docker rm || echo "Failed to remove some containers"
          fi

          # Cleanup Docker network
          if docker network ls | grep -q "${{ env.DOCKER_NETWORK_NAME }}"; then
            if ! docker network rm "${{ env.DOCKER_NETWORK_NAME }}"; then
              echo "Failed to remove network ${{ env.DOCKER_NETWORK_NAME }}, it might be in use"
            fi
          fi

          echo "Cleanup completed."
          sleep 5

  initialize_swarm:
    needs: cleanup
    runs-on: self-hosted
    outputs:
      swarm-manager-ip: ${{ steps.setup_swarm.outputs.swarm-manager-ip }}
      swarm-worker-token: ${{ steps.setup_swarm.outputs.swarm-worker-token }}
      network-id: ${{ steps.setup_network.outputs.network-id }}
      manager-hostname: ${{ steps.setup_swarm.outputs.manager-hostname }}
    steps:
      - name: Debug Runner Information
        run: |
          echo "Runner Name: ${{ runner.name }}"
          echo "Hostname: $(hostname)"
          echo "Runner Labels: ${{ runner.labels }}"

      - name: Verify Runner for Swarm Initialization
        if: ${{ runner.name == 'TNO' }}
        run: echo "Runner is TNO - proceeding with swarm initialization."

      - name: Skip Swarm Initialization on Non-Manager Runners
        if: ${{ runner.name != 'TNO' }}
        run: echo "Runner is not TNO - skipping swarm initialization."

      - name: Setup Swarm Manager
        id: setup_swarm
        if: ${{ runner.name == 'TNO' }}
        run: |
          HOSTNAME=$(hostname)
          echo "Hostname: $HOSTNAME"

          IP="${{ secrets.MANAGER_IP }}"
          if [ -z "$IP" ]; then
            echo "::error::MANAGER_IP secret is not set."
            exit 1
          fi
          echo "Using Manager IP: $IP"
          echo "Manager Hostname: $HOSTNAME"

          # Force leave any existing swarm. If not in a swarm, this will error, but we can ignore it.
          echo "Forcing leave from any existing swarm (if present)..."
          docker swarm leave --force || echo "Not currently in a swarm, continuing..."

          # Now initialize a new swarm
          echo "Initializing new swarm..."
          if ! docker swarm init --advertise-addr $IP --listen-addr $IP:2377; then
            echo "::error::Failed to initialize swarm."
            exit 1
          fi

          WORKER_TOKEN=$(docker swarm join-token worker -q)

          echo "swarm-manager-ip=$IP" >> $GITHUB_OUTPUT
          echo "swarm-worker-token=$WORKER_TOKEN" >> $GITHUB_OUTPUT
          echo "manager-hostname=$HOSTNAME" >> $GITHUB_OUTPUT

      - name: Setup Overlay Network
        id: setup_network
        if: ${{ runner.name == 'TNO' }}
        run: |
          echo "Creating overlay network..."
          NETWORK_ID=$(docker network create \
            --driver overlay \
            --attachable \
            --subnet 10.0.1.0/24 \
            --opt encrypted \
            --opt com.docker.network.driver.mtu=1450 \
            ${{ env.DOCKER_NETWORK_NAME }})

          if [ -z "$NETWORK_ID" ]; then
            echo "::error::Failed to create network"
            exit 1
          fi

          echo "network-id=$NETWORK_ID" >> $GITHUB_OUTPUT
          sleep 10

          if ! docker network inspect ${{ env.DOCKER_NETWORK_NAME }} > /dev/null 2>&1; then
            echo "::error::Network '${{ env.DOCKER_NETWORK_NAME }}' not available after creation."
            exit 1
          fi

          echo "Overlay network '${{ env.DOCKER_NETWORK_NAME }}' created successfully."

  join_swarm:
    needs: initialize_swarm
    runs-on: self-hosted
    strategy:
      matrix:
        fuzzer: [restler, wuppiefuzz, evomaster]
      fail-fast: false
    steps:
      - name: Debug Runner Information
        run: |
          echo "Runner Name: ${{ runner.name }}"
          echo "Hostname: $(hostname)"
          echo "Runner Labels: ${{ runner.labels }}"

      - name: Verify Runner for Swarm Joining
        if: ${{ runner.name == 'TNO2' }}
        run: echo "Runner is TNO2 - proceeding with swarm joining."

      - name: Skip Swarm Joining on Non-Worker Runners
        if: ${{ runner.name != 'TNO2' }}
        run: echo "Runner is not TNO2 - skipping swarm joining."

      - name: Cleanup Worker Before Joining
        if: ${{ runner.name == 'TNO2' }}
        run: |
          # Kill processes using known ports
          for port in ${{ env.VAMPI_RESTLER_PORT }} ${{ env.VAMPI_WUPPIEFUZZ_PORT }} ${{ env.VAMPI_EVOMASTER_PORT }}; do
            pid=$(lsof -ti :$port) || true
            if [ -n "$pid" ]; then
              echo "Killing process using port $port"
              kill -9 $pid || echo "Failed to kill process on port $port"
            fi
          done

          # Cleanup Docker resources
          if docker ps -q | grep -q .; then
            docker ps -q | xargs docker stop || echo "Failed to stop some containers"
          fi
          if docker ps -aq | grep -q .; then
            docker ps -aq | xargs docker rm || echo "Failed to remove some containers"
          fi

          # Leave any existing swarm
          if docker info --format '{{.Swarm.LocalNodeState}}' | grep -q 'active'; then
            docker swarm leave --force || echo "::warning::Failed to leave previous swarm."
          fi

          sleep 5

      - name: Join Swarm
        if: ${{ runner.name == 'TNO2' }}
        shell: bash
        run: |
          HOSTNAME=$(hostname)
          echo "Current Hostname: $HOSTNAME"
          echo "Manager Hostname: ${{ needs.initialize_swarm.outputs.manager-hostname }}"
          echo "Manager IP: ${{ secrets.MANAGER_IP }}"

          if [ "$HOSTNAME" == "${{ needs.initialize_swarm.outputs.manager-hostname }}" ]; then
            echo "This is the manager node, skipping join."
          else
            echo "Joining swarm as worker..."
            if ! docker swarm join --token ${{ needs.initialize_swarm.outputs.swarm-worker-token }} ${{ secrets.MANAGER_IP }}:2377; then
              echo "::error::Failed to join swarm"
              exit 1
            fi
            echo "Successfully joined swarm"

            echo "Waiting for network propagation..."
            for i in $(seq 1 30); do
              if docker network ls | grep -q "${{ env.DOCKER_NETWORK_NAME }}"; then
                echo "Network is available on this node."
                docker network inspect ${{ env.DOCKER_NETWORK_NAME }} > /dev/null 2>&1 && break
              fi
              if [ $i -eq 30 ]; then
                echo "::error::Network never became available"
                exit 1
              fi
              echo "Waiting for network... attempt $i/30"
              sleep 2
            done
          fi

  setup_target_application:
    needs: [initialize_swarm, join_swarm]
    runs-on: self-hosted
    strategy:
      matrix:
        fuzzer: [restler, wuppiefuzz, evomaster]
      fail-fast: false
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4.0.0

      - name: Set VAMPI_PORT
        run: |
          case "${{ matrix.fuzzer }}" in
            "restler")
              echo "VAMPI_PORT=${{ env.VAMPI_RESTLER_PORT }}" >> $GITHUB_ENV
              ;;
            "wuppiefuzz")
              echo "VAMPI_PORT=${{ env.VAMPI_WUPPIEFUZZ_PORT }}" >> $GITHUB_ENV
              ;;
            "evomaster")
              echo "VAMPI_PORT=${{ env.VAMPI_EVOMASTER_PORT }}" >> $GITHUB_ENV
              ;;
          esac

      - name: Start VAmPI
        run: |
          cd services/vampi

          pid=$(lsof -ti :$VAMPI_PORT) || true
          if [ -n "$pid" ]; then
            echo "Killing process using port $VAMPI_PORT"
            kill -9 $pid || echo "Failed to kill process on port $VAMPI_PORT"
          fi

          docker compose down -v || echo "::warning::Failed to run docker compose down."
          sleep 5

          echo "Verifying network availability..."
          for i in $(seq 1 30); do
            if docker network ls | grep -q "${{ env.DOCKER_NETWORK_NAME }}"; then
              echo "Network is available"
              break
            fi
            if [ $i -eq 30 ]; then
              echo "::error::Network not available after 30 attempts"
              exit 1
            fi
            echo "Waiting for network... attempt $i/30"
            sleep 2
          done

          export PORT=$VAMPI_PORT
          export DOCKER_NETWORK_NAME=${{ env.DOCKER_NETWORK_NAME }}

          RETRY_COUNT=0
          while [ $RETRY_COUNT -lt ${{ env.MAX_STARTUP_RETRIES }} ]; do
            echo "Starting VAmPI (Attempt $((RETRY_COUNT + 1))/${{ env.MAX_STARTUP_RETRIES }})"
            
            if docker compose up -d; then
              for i in $(seq 1 ${{ env.HEALTH_CHECK_TIMEOUT }}); do
                if curl -s http://localhost:$VAMPI_PORT/api/v1/docs > /dev/null; then
                  echo "VAmPI is healthy and responding"
                  docker compose ps
                  break 2
                fi
                echo "Waiting for VAmPI to be ready... ($i/${{ env.HEALTH_CHECK_TIMEOUT }})"
                sleep 1
              done
            fi

            echo "::warning::Attempt $((RETRY_COUNT + 1)) failed, cleaning up..."
            docker compose down -v
            sleep 10
            RETRY_COUNT=$((RETRY_COUNT + 1))
          done

          if [ $RETRY_COUNT -eq ${{ env.MAX_STARTUP_RETRIES }} ]; then
            echo "::error::Failed to start VAmPI after ${{ env.MAX_STARTUP_RETRIES }} attempts"
            docker compose logs || true
            # Not exiting here ensures other fuzzers continue
          fi

  prepare_fuzzers:
    needs: [initialize_swarm]
    runs-on: self-hosted
    strategy:
      matrix:
        fuzzer: [restler, wuppiefuzz, evomaster]
      fail-fast: false
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4.0.0

      - name: Setup RESTler
        if: matrix.fuzzer == 'restler'
        run: |
          echo "Setting up RESTler..."
          # RESTler setup steps here

      - name: Setup WuppieFuzz
        if: matrix.fuzzer == 'wuppiefuzz'
        run: |
          echo "Setting up WuppieFuzz..."
          # WuppieFuzz setup steps here

      - name: Setup EvoMaster
        if: matrix.fuzzer == 'evomaster'
        run: |
          echo "Setting up EvoMaster..."
          cd "${{ github.workspace }}/services/evomaster"
          ls -la  # Debug: list files
          docker compose -f docker-compose.evomaster.yml build --no-cache evomaster
          mkdir -p evomaster_results

      - name: Upload Fuzzer Artifacts
        uses: actions/upload-artifact@v3.1.2
        with:
          name: fuzzer-${{ matrix.fuzzer }}-artifacts
          path: tools
          retention-days: 1

  prepare_openapi_specs:
    needs: [setup_target_application]
    runs-on: self-hosted
    if: always()
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4.0.0

      - name: Generate OpenAPI Specs
        run: |
          for fuzzer in restler wuppiefuzz evomaster; do
            case $fuzzer in
              restler)
                PORT=${{ env.VAMPI_RESTLER_PORT }}
                OUTPUT_DIR="${{ env.BASE_DIR }}/workspace/restler"
                ;;
              wuppiefuzz)
                PORT=${{ env.VAMPI_WUPPIEFUZZ_PORT }}
                OUTPUT_DIR="${{ env.BASE_DIR }}/wuppiefuzz_workspace"
                ;;
              evomaster)
                PORT=${{ env.VAMPI_EVOMASTER_PORT }}
                OUTPUT_DIR="${{ env.BASE_DIR }}/evomaster_workspace"
                ;;
            esac
            
            mkdir -p "$OUTPUT_DIR"
            cp ${{ env.BASE_DIR }}/services/vampi/openapi_specs/openapi3.yml "$OUTPUT_DIR/openapi3.yml"
            sed -i "s|http://localhost:5000|http://localhost:$PORT|g" "$OUTPUT_DIR/openapi3.yml"
          done

      - name: Upload OpenAPI Specs
        uses: actions/upload-artifact@v3.1.2
        with:
          name: openapi-specs
          path: |
            ${{ env.BASE_DIR }}/workspace/restler/openapi3.yml
            ${{ env.BASE_DIR }}/wuppiefuzz_workspace/openapi3.yml
            ${{ env.BASE_DIR }}/evomaster_workspace/openapi3.yml
          retention-days: 1

  run_fuzzing:
    needs: [prepare_fuzzers, prepare_openapi_specs, setup_target_application]
    runs-on: self-hosted
    strategy:
      matrix:
        fuzzer: [restler, wuppiefuzz, evomaster]
      fail-fast: false
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4.0.0

      - name: Download Fuzzer Artifacts
        uses: actions/download-artifact@v3.1.2
        with:
          name: fuzzer-${{ matrix.fuzzer }}-artifacts
          path: tools

      - name: Download OpenAPI Specs
        uses: actions/download-artifact@v3.1.2
        with:
          name: openapi-specs
          path: openapi_specs

      - name: Set VAMPI_PORT
        run: |
          case "${{ matrix.fuzzer }}" in
            "restler")
              echo "VAMPI_PORT=${{ env.VAMPI_RESTLER_PORT }}" >> $GITHUB_ENV
              ;;
            "wuppiefuzz")
              echo "VAMPI_PORT=${{ env.VAMPI_WUPPIEFUZZ_PORT }}" >> $GITHUB_ENV
              ;;
            "evomaster")
              echo "VAMPI_PORT=${{ env.VAMPI_EVOMASTER_PORT }}" >> $GITHUB_ENV
              ;;
          esac

      - name: Run RESTler
        if: matrix.fuzzer == 'restler'
        run: |
          echo "Running RESTler..."
          # RESTler execution steps here

      - name: Run WuppieFuzz
        if: matrix.fuzzer == 'wuppiefuzz'
        run: |
          echo "Running WuppieFuzz..."
          # WuppieFuzz execution steps here

      - name: Run EvoMaster
        if: matrix.fuzzer == 'evomaster'
        run: |
          echo "Running EvoMaster..."
          cd "${{ github.workspace }}/services/evomaster"
          docker compose -f docker-compose.evomaster.yml run --rm evomaster \
            -e SPEC_PATH="/specs/openapi3.yml" \
            -e OUTPUT_DIR="/evomaster/results" \
            -e TARGET_URL="http://vampi-vulnerable-evomaster:${{ env.VAMPI_PORT }}" \
            -e TIME_BUDGET="600"

      - name: Upload Fuzzing Results
        uses: actions/upload-artifact@v3.1.2
        with:
          name: fuzzing-results-${{ matrix.fuzzer }}
          path: |
            tools/**/results
            tools/**/output
          retention-days: 1

  summarize_results:
    needs: run_fuzzing
    runs-on: self-hosted
    if: always()
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4.0.0

      - name: Download RESTler Results
        uses: actions/download-artifact@v3.1.2
        with:
          name: fuzzing-results-restler
          path: all_results/restler-results
          if-no-files-found: warn

      - name: Download WuppieFuzz Results
        uses: actions/download-artifact@v3.1.2
        with:
          name: fuzzing-results-wuppiefuzz
          path: all_results/wuppiefuzz-results
          if-no-files-found: warn

      - name: Download EvoMaster Results
        uses: actions/download-artifact@v3.1.2
        with:
          name: fuzzing-results-evomaster
          path: all_results/evomaster-results
          if-no-files-found: warn

      - name: List Downloaded Artifacts
        run: |
          echo "Listing RESTler Results:"
          ls -la all_results/restler-results || echo "No RESTler results found."
          echo "Listing WuppieFuzz Results:"
          ls -la all_results/wuppiefuzz-results || echo "No WuppieFuzz results found."
          echo "Listing EvoMaster Results:"
          ls -la all_results/evomaster-results || echo "No EvoMaster results found."

      - name: Final Cleanup
        run: |
          echo "Pruning Docker containers..."
          docker container prune -f || echo "Failed to prune Docker containers."
          echo "Pruning Docker networks..."
          docker network prune -f || echo "Failed to prune Docker networks."
