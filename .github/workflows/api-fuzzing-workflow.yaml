name: API Fuzzing Pipeline

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

permissions:
  contents: read

env:
  DOCKER_NETWORK_NAME: cicd_network
  VAMPI_RESTLER_PORT: 5012
  VAMPI_WUPPIEFUZZ_PORT: 5022
  VAMPI_EVOMASTER_PORT: 5032
  BASE_DIR: ${{ github.workspace }}
  FUZZERS: restler wuppiefuzz evomaster
  MAX_STARTUP_RETRIES: 3
  HEALTH_CHECK_TIMEOUT: 30
  NETWORK_TIMEOUT: 60

jobs:
  # 1. Initial cleanup
  cleanup:
    runs-on: self-hosted
    steps:
      - name: Cleanup Previous Setup
        run: |
          echo "Cleaning up previous setup..."
          # Kill any processes using known ports
          for port in ${{ env.VAMPI_RESTLER_PORT }} ${{ env.VAMPI_WUPPIEFUZZ_PORT }} ${{ env.VAMPI_EVOMASTER_PORT }}; do
            pid=$(lsof -ti :$port) || true
            if [ -n "$pid" ]; then
              echo "Killing process using port $port"
              kill -9 $pid || echo "Failed to kill process on port $port"
            fi
          done
          # Cleanup Docker containers
          if docker ps -q | grep -q .; then
            docker ps -q | xargs docker stop || echo "Failed to stop some running containers"
          fi
          if docker ps -aq | grep -q .; then
            docker ps -aq | xargs docker rm || echo "Failed to remove some containers"
          fi
          # Cleanup Docker network
          if docker network ls | grep -q "${{ env.DOCKER_NETWORK_NAME }}"; then
            if ! docker network rm "${{ env.DOCKER_NETWORK_NAME }}"; then
              echo "Failed to remove network ${{ env.DOCKER_NETWORK_NAME }}, it might be in use"
            fi
          fi
          echo "Cleanup completed."
          sleep 5

  # 2. Initialize Swarm infrastructure
  initialize_swarm:
    needs: cleanup
    runs-on: self-hosted
    outputs:
      swarm-manager-ip: ${{ steps.setup_swarm.outputs.swarm-manager-ip }}
      swarm-worker-token: ${{ steps.setup_swarm.outputs.swarm-worker-token }}
      network-id: ${{ steps.setup_network.outputs.network-id }}
      manager-hostname: ${{ steps.setup_swarm.outputs.manager-hostname }}
      swarm-initialized: ${{ steps.setup_swarm.outputs.swarm-initialized }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Count Active Runners
        id: count_runners
        run: |
          echo "TOTAL_RUNNERS=$(gh api /repos/${{ github.repository }}/actions/runners | jq '.total_count')" >> $GITHUB_ENV
        env:
          GH_TOKEN: ${{ github.token }}

      - name: Make manage-swarm.sh executable
        run: chmod +x ./scripts/manage-swarm.sh

      - name: Manage Swarm State
        if: contains(github.runner.labels, 'swarm-manager')
        env:
          MANAGER_IP: ${{ secrets.MANAGER_IP }}
        run: |
          ./scripts/manage-swarm.sh ${{ env.TOTAL_RUNNERS }}
          
          # Set outputs for other jobs
          echo "swarm-manager-ip=${{ secrets.MANAGER_IP }}" >> $GITHUB_OUTPUT
          WORKER_TOKEN=$(docker swarm join-token worker -q)
          echo "swarm-worker-token=$WORKER_TOKEN" >> $GITHUB_OUTPUT
          echo "manager-hostname=$(hostname)" >> $GITHUB_OUTPUT
          echo "swarm-initialized=true" >> $GITHUB_OUTPUT

      - name: Setup Docker Network
        id: setup_network
        if: contains(github.runner.labels, 'swarm-manager')
        run: |
          # Check if network exists first
          if ! docker network ls | grep -q "${{ env.DOCKER_NETWORK_NAME }}"; then
            echo "Creating overlay network ${{ env.DOCKER_NETWORK_NAME }}"
            NETWORK_ID=$(docker network create --driver overlay --attachable ${{ env.DOCKER_NETWORK_NAME }})
            echo "network-id=$NETWORK_ID" >> $GITHUB_OUTPUT
          else
            echo "Network ${{ env.DOCKER_NETWORK_NAME }} already exists"
            NETWORK_ID=$(docker network ls --filter name=${{ env.DOCKER_NETWORK_NAME }} --format "{{.ID}}")
            echo "network-id=$NETWORK_ID" >> $GITHUB_OUTPUT
          fi
          
          # Verify network was created/exists and is overlay type
          if ! docker network inspect ${{ env.DOCKER_NETWORK_NAME }} --format "{{.Driver}}" | grep -q "overlay"; then
            echo "::error::Network ${{ env.DOCKER_NETWORK_NAME }} is not an overlay network"
            exit 1
          fi

  # 3. Join workers to Swarm
  join_swarm:
    needs: initialize_swarm
    runs-on: self-hosted
    strategy:
      matrix:
        fuzzer: [restler, wuppiefuzz, evomaster]
      fail-fast: false
    steps:
      - name: Debug Runner Information
        run: |
          echo "Runner Labels: ${{ join(github.runner.labels, ', ') }}"
          echo "Hostname: $(hostname)"

      - name: Verify Runner for Swarm Joining
        if: contains(github.runner.labels, 'swarm-worker')
        run: echo "Runner has swarm-worker label - proceeding with swarm joining."

      - name: Skip Swarm Joining on Non-Worker Runners
        if: "!contains(github.runner.labels, 'swarm-worker')"
        run: echo "Runner does not have swarm-worker label - skipping swarm joining."

      - name: Cleanup Worker Before Joining
        if: contains(github.runner.labels, 'swarm-worker') && needs.initialize_swarm.outputs.swarm-initialized == 'true'
        run: |
          # Kill processes using known ports
          for port in ${{ env.VAMPI_RESTLER_PORT }} ${{ env.VAMPI_WUPPIEFUZZ_PORT }} ${{ env.VAMPI_EVOMASTER_PORT }}; do
            pid=$(lsof -ti :$port) || true
            if [ -n "$pid" ]; then
              echo "Killing process using port $port"
              kill -9 $pid || echo "Failed to kill process on port $port"
            fi
          done
          # Cleanup Docker resources
          if docker ps -q | grep -q .; then
            docker ps -q | xargs docker stop || echo "Failed to stop some running containers"
          fi
          if docker ps -aq | grep -q .; then
            docker ps -aq | xargs docker rm || echo "Failed to remove some containers"
          fi
          # Leave any existing swarm
          if docker info --format '{{.Swarm.LocalNodeState}}' | grep -q 'active'; then
            docker swarm leave --force || echo "::warning::Failed to leave previous swarm."
          fi
          sleep 5

      - name: Join Swarm
        if: contains(github.runner.labels, 'swarm-worker') && needs.initialize_swarm.outputs.swarm-initialized == 'true'
        shell: bash
        run: |
          HOSTNAME=$(hostname)
          echo "Current Hostname: $HOSTNAME"
          echo "Manager Hostname: ${{ needs.initialize_swarm.outputs.manager-hostname }}"
          echo "Manager IP: ${{ secrets.MANAGER_IP }}"
          if [ "$HOSTNAME" == "${{ needs.initialize_swarm.outputs.manager-hostname }}" ]; then
            echo "This is the manager node, skipping join."
          else
            echo "Joining swarm as worker..."
            
            # Ensure Docker daemon is running with proper network settings
            sudo systemctl stop docker || true
            sudo sed -i 's/^ExecStart=.*/ExecStart=\/usr\/bin\/dockerd -H fd:\/\/ --containerd=\/run\/containerd\/containerd.sock --iptables=true --ip-masq=true --ip-forward=true/' /lib/systemd/system/docker.service
            sudo systemctl daemon-reload
            sudo systemctl start docker
            
            # Wait for Docker to be ready
            echo "Waiting for Docker to be ready..."
            timeout 30s bash -c 'until docker info &>/dev/null; do sleep 1; done'
            
            # Verify connectivity to manager
            echo "Verifying connectivity to manager..."
            if ! timeout 5s bash -c "</dev/tcp/${{ secrets.MANAGER_IP }}/2377"; then
              echo "::error::Cannot connect to manager port 2377"
              exit 1
            fi
            
            # Try joining with increased timeout
            if ! timeout 30s docker swarm join --token ${{ needs.initialize_swarm.outputs.swarm-worker-token }} ${{ secrets.MANAGER_IP }}:2377; then
              echo "::error::Failed to join swarm"
              docker swarm leave --force || true
              exit 1
            fi
            echo "Successfully joined swarm"
            # Verify node joined successfully with increased timeout
            echo "Verifying node joined successfully..."
            for i in $(seq 1 60); do
              if docker node ls 2>/dev/null | grep -q "$(hostname)"; then
                echo "Node successfully joined and visible in swarm"
                break
              fi
              if [ $i -eq 60 ]; then
                echo "::error::Node failed to appear in swarm after joining"
                exit 1
              fi
              echo "Waiting for node to appear in swarm... attempt $i/60"
              sleep 2
            done
            # Add node labels
            echo "Adding node labels..."
            if docker node ls --filter role=worker | grep -q "$(hostname)"; then
              docker node update --label-add type=fuzzer $(hostname)
            fi

  # 4. Verify Swarm setup
  verify_swarm:
    needs: [initialize_swarm, join_swarm]
    runs-on: self-hosted
    if: contains(github.runner.labels, 'swarm-manager')
    steps:
      - name: Verify Swarm and Network
        run: |
          # Verify swarm mode is active
          if ! docker info | grep -q "Swarm: active"; then
            echo "::error::Not in swarm mode - swarm initialization may have failed"
            exit 1
          fi
          
          # Verify network exists and is overlay type
          if ! docker network ls --filter driver=overlay | grep -q "${{ env.DOCKER_NETWORK_NAME }}"; then
            echo "::error::Required overlay network ${{ env.DOCKER_NETWORK_NAME }} not found"
            docker network ls
            exit 1
          fi
          
          # Verify node labels
          if ! docker node ls --format "{{.Hostname}} {{.Labels}}" | grep -q "type=fuzzer"; then
            echo "::error::Worker nodes not properly labeled"
            docker node ls
            exit 1
          fi
          
          echo "Swarm configuration verified successfully"

  # 5. Prepare OpenAPI specs (can run in parallel with image building)
  prepare_specs:
    needs: verify_swarm
    runs-on: self-hosted
    if: contains(github.runner.labels, 'swarm-manager')
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4.0.0

      - name: Copy OpenAPI Specs to Volumes
        run: |
          # Create temporary directory
          mkdir -p specs_temp
          cp services/vampi/openapi_specs/openapi3.yml specs_temp/
          
          # Copy specs to volumes
          docker run --rm \
            -v $(pwd)/specs_temp:/source \
            -v openapi_spec:/dest \
            alpine cp /source/openapi3.yml /dest/

  # 6. Build and push images (can run in parallel with specs preparation)
  build_and_push_images:
    needs: verify_swarm
    runs-on: self-hosted
    strategy:
      matrix:
        service: [vampi-vulnerable, wuppiefuzz, restler, evomaster]
      fail-fast: false
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4.0.0

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build and Push VAmPI
        if: matrix.service == 'vampi-vulnerable'
        run: |
          cd services/vampi
          docker buildx build \
            --platform linux/amd64 \
            --target vulnerable \
            --tag ${REGISTRY:-localhost}/vampi-vulnerable:${TAG:-latest} \
            --push \
            .

      - name: Build and Push WuppieFuzz
        if: matrix.service == 'wuppiefuzz'
        run: |
          cd services/wuppiefuzz
          docker buildx build \
            --platform linux/amd64 \
            --file Dockerfile.wuppiefuzz \
            --tag ${REGISTRY:-localhost}/wuppiefuzz:${TAG:-latest} \
            --push \
            .

      - name: Build and Push RESTler
        if: matrix.service == 'restler'
        run: |
          cd services/restler
          docker buildx build \
            --platform linux/amd64 \
            --file Dockerfile.restler \
            --tag ${REGISTRY:-localhost}/restler:${TAG:-latest} \
            --push \
            .

      - name: Build and Push EvoMaster
        if: matrix.service == 'evomaster'
        run: |
          cd services/evomaster
          docker buildx build \
            --platform linux/amd64 \
            --file Dockerfile.evomaster \
            --tag ${REGISTRY:-localhost}/evomaster:${TAG:-latest} \
            --push \
            .

  # 7. Deploy stack (after both specs and images are ready)
  deploy_stack:
    needs: [prepare_specs, build_and_push_images]
    runs-on: self-hosted
    if: contains(github.runner.labels, 'swarm-manager')
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4.0.0

      - name: Deploy Stack
        run: |
          # Set environment variables for stack deployment
          export REGISTRY=${REGISTRY:-localhost}
          export TAG=${TAG:-latest}
          
          # Remove any existing stack
          docker stack rm fuzzing-stack || true
          sleep 10
          
          # Deploy the new stack
          RETRY_COUNT=0
          MAX_RETRIES=3
          
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            echo "Deploying stack (Attempt $((RETRY_COUNT + 1))/$MAX_RETRIES)"
            
            if docker stack deploy -c docker-swarm.yml fuzzing-stack; then
              # Wait for services to be running
              echo "Waiting for services to start..."
              for i in $(seq 1 60); do
                RUNNING_COUNT=$(docker stack services fuzzing-stack --format "{{.Replicas}}" | grep -c "1/1" || echo "0")
                EXPECTED_COUNT=5  # manager, vampi, wuppiefuzz, restler, evomaster
                if [ "$RUNNING_COUNT" -eq "$EXPECTED_COUNT" ]; then
                  echo "All services are running"
                  docker stack services fuzzing-stack
                  exit 0
                fi
                echo "Services running: $RUNNING_COUNT/$EXPECTED_COUNT"
                sleep 2
              done
            fi
            
            echo "Attempt $((RETRY_COUNT + 1)) failed, cleaning up..."
            docker stack rm fuzzing-stack || true
            sleep 10
            RETRY_COUNT=$((RETRY_COUNT + 1))
          done
          
          echo "::error::Failed to deploy stack after $MAX_RETRIES attempts"
          docker stack services fuzzing-stack || true
          exit 1

  # 8. Run fuzzing tests
  run_fuzzing:
    needs: deploy_stack
    runs-on: self-hosted
    if: contains(github.runner.labels, 'swarm-manager')
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4.0.0

      - name: Wait for Services
        run: |
          echo "Waiting for all services to be healthy..."
          for i in $(seq 1 60); do
            UNHEALTHY_COUNT=$(docker stack services fuzzing-stack --format "{{.Name}} {{.Replicas}}" | grep -v "1/1" | wc -l)
            if [ "$UNHEALTHY_COUNT" -eq 0 ]; then
              echo "All services are healthy"
              break
            fi
            if [ $i -eq 60 ]; then
              echo "::error::Services failed to become healthy"
              docker stack services fuzzing-stack
              exit 1
            fi
            echo "Waiting for services to be healthy... ($i/60)"
            sleep 5
          done

      - name: Run Fuzzing Tests
        run: |
          # Wait for VAmPI to be ready
          echo "Waiting for VAmPI to be ready..."
          for i in $(seq 1 30); do
            if curl -s http://localhost:5002/api/v1/docs > /dev/null; then
              echo "VAmPI is ready"
              break
            fi
            if [ $i -eq 30 ]; then
              echo "::error::VAmPI failed to become ready"
              exit 1
            fi
            echo "Waiting for VAmPI... ($i/30)"
            sleep 2
          done

          # Monitor fuzzing services
          echo "Monitoring fuzzing services..."
          TIMEOUT=3600  # 1 hour timeout
          START_TIME=$(date +%s)
          
          while true; do
            CURRENT_TIME=$(date +%s)
            ELAPSED_TIME=$((CURRENT_TIME - START_TIME))
            
            if [ $ELAPSED_TIME -gt $TIMEOUT ]; then
              echo "Fuzzing timeout reached"
              break
            fi
            
            # Check service status
            if ! docker stack services fuzzing-stack --format "{{.Name}} {{.Replicas}}"; then
              echo "::error::Failed to get service status"
              exit 1
            fi
            
            # Check for completed fuzzing
            COMPLETED_COUNT=$(docker service logs fuzzing-stack_wuppiefuzz 2>&1 | grep -c "Fuzzing completed" || true)
            RESTLER_COMPLETED=$(docker service logs fuzzing-stack_restler 2>&1 | grep -c "RESTler done" || true)
            EVO_COMPLETED=$(docker service logs fuzzing-stack_evomaster 2>&1 | grep -c "EvoMaster done" || true)
            
            if [ $COMPLETED_COUNT -gt 0 ] && [ $RESTLER_COMPLETED -gt 0 ] && [ $EVO_COMPLETED -gt 0 ]; then
              echo "All fuzzing completed successfully"
              break
            fi
            
            echo "Fuzzing in progress... (${ELAPSED_TIME}s elapsed)"
            sleep 30
          done

      - name: Collect Results
        run: |
          echo "Collecting fuzzing results..."
          
          # Create results directory
          mkdir -p fuzzing_results
          
          # Copy results from volumes
          docker run --rm \
            -v wuppiefuzz_reports:/reports \
            -v $(pwd)/fuzzing_results:/output \
            alpine cp -r /reports /output/wuppiefuzz
            
          docker run --rm \
            -v restler_output:/output \
            -v $(pwd)/fuzzing_results:/dest \
            alpine cp -r /output /dest/restler
            
          docker run --rm \
            -v evomaster_results:/results \
            -v $(pwd)/fuzzing_results:/dest \
            alpine cp -r /results /dest/evomaster

      - name: Upload Results
        uses: actions/upload-artifact@v4
        with:
          name: fuzzing-results
          path: fuzzing_results
          retention-days: 7

  # 9. Summarize results
  summarize_results:
    needs: run_fuzzing
    runs-on: self-hosted
    if: always()
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4.0.0

      - name: Download Results
        uses: actions/download-artifact@v4
        with:
          name: fuzzing-results
          path: all_results

      - name: List Results
        run: |
          echo "Listing Results:"
          ls -la all_results || echo "No results found."

      - name: Final Cleanup
        run: |
          echo "Pruning Docker containers..."
          docker container prune -f || echo "Failed to prune Docker containers."
          echo "Pruning Docker networks..."
          docker network prune -f || echo "Failed to prune Docker networks."
